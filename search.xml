<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>定时器</title>
      <link href="/2018/12/18/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2018/12/18/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>熟悉外部中断相关实验</p><p>利用定时器使LED周期性闪烁</p><a id="more"></a><h2 id="1、通过定时器T1查询方式控制LED1周期性闪烁"><a href="#1、通过定时器T1查询方式控制LED1周期性闪烁" class="headerlink" title="1、通过定时器T1查询方式控制LED1周期性闪烁"></a><strong>1、通过定时器T1查询方式控制LED1周期性闪烁</strong></h2><h3 id="（1）定时器"><a href="#（1）定时器" class="headerlink" title="（1）定时器"></a>（1）定时器</h3><p>定时器就类似于计时器，可以顺计时，可以倒计时。</p><p>我们可以事先给他设置一个值，确定它的工作时间t。在某一时刻让它开始工作，然后工作的时间达到t后，</p><p>就产生一个行为或者更准确的说应该是一个中断请求，</p><p>然后去处理这个中断，比如我们的LED灯就会亮。这么一来，它的功能就相当于一个延时函数，只不过延时函数是用程序来控制时间，而定时器是通过具体的硬件来实现对时间的控制。我认为定时器控制的时间应该更准确一些。</p><p>CC2530有5个定时器，一个十六位（定时器1）、两个8位定时器（定时器3和定时器4）、一个用于休眠的定时器（睡眠定时器）和一个MAC定时器。本次试验只涉及到定时器1。</p><h3 id="（2）通过定时器T1查询方式控制LED1周期性闪烁VS通过器时器T3中断方式控制LED1周期性闪烁"><a href="#（2）通过定时器T1查询方式控制LED1周期性闪烁VS通过器时器T3中断方式控制LED1周期性闪烁" class="headerlink" title="（2）通过定时器T1查询方式控制LED1周期性闪烁VS通过器时器T3中断方式控制LED1周期性闪烁"></a>（2）通过定时器T1查询方式控制LED1周期性闪烁VS通过器时器T3中断方式控制LED1周期性闪烁</h3><p>如果使用的中断的话定时时间一到马上执行中断函数；如果使用查询的话定时时间到了之后必须等到程序执行到判断语句的时候才能执行。所以实时性差。</p><h3 id="（3）定时器T1的功能"><a href="#（3）定时器T1的功能" class="headerlink" title="（3）定时器T1的功能"></a>（3）定时器T1的功能</h3><p>定时器T1是一个独立的16位定时器，支持定时和计数功能，有输入捕获、输出比较和PWN的功能。定时器1有5个独立的输出捕获和输入比较通道。每个通道使用通道使用一个I/O引脚。</p><p>定时器1的主要功能</p><p>如下：</p><h4 id="1）5个独立的捕获、比较通道。"><a href="#1）5个独立的捕获、比较通道。" class="headerlink" title="1）5个独立的捕获、比较通道。"></a>1）5个独立的捕获、比较通道。</h4><p>输入捕获的工作原理：</p><p>当你设置的捕获开始的时候，cpu会将计数寄存器的值复制到捕获比较寄存器中并开始计数，当再次捕捉到电平变化时，这是计数寄存器中的值减去刚才复制的值就是这段电平的持续时间，你可以设置上升沿捕获、下降沿捕获、或者上升沿下降沿都捕获。它没多大用处，最常用来测频率。</p><p>输出比较的工作原理：</p><p>这里有两个单元：一个计数器单元和一个比较单元，比较单元就是个双缓冲寄存器，比较单元的值是可以根据不同的模式设置的，与此同时，计数器在不停的计数，并不停的与比较寄存器中的值进行比较，当计数器的值与比较寄存器的值相等的时候一个比较匹配就发生了，根据自己的设置，就会产生不同的波形了。</p><h4 id="2）上升沿、下降沿或任何边沿的输入捕获。"><a href="#2）上升沿、下降沿或任何边沿的输入捕获。" class="headerlink" title="2）上升沿、下降沿或任何边沿的输入捕获。"></a>2）上升沿、下降沿或任何边沿的输入捕获。</h4><h4 id="3）设置、清除或切换输出比较。"><a href="#3）设置、清除或切换输出比较。" class="headerlink" title="3）设置、清除或切换输出比较。"></a>3）设置、清除或切换输出比较。</h4><h4 id="4）3种运行模式：自由运行、模计数模式和正-倒计数操作模式。"><a href="#4）3种运行模式：自由运行、模计数模式和正-倒计数操作模式。" class="headerlink" title="4）3种运行模式：自由运行、模计数模式和正/倒计数操作模式。"></a>4）3种运行模式：自由运行、模计数模式和正/倒计数操作模式。</h4><h4 id="5）可被1、8、32或128整除的时钟分频器。"><a href="#5）可被1、8、32或128整除的时钟分频器。" class="headerlink" title="5）可被1、8、32或128整除的时钟分频器。"></a>5）可被1、8、32或128整除的时钟分频器。</h4><h4 id="6）在捕获、比较和最终计数上生成中断请求。"><a href="#6）在捕获、比较和最终计数上生成中断请求。" class="headerlink" title="6）在捕获、比较和最终计数上生成中断请求。"></a>6）在捕获、比较和最终计数上生成中断请求。</h4><h4 id="7）具有DMA触发功能。"><a href="#7）具有DMA触发功能。" class="headerlink" title="7）具有DMA触发功能。"></a>7）具有DMA触发功能。</h4><h4 id="DMA触发可以通过设置DMA的触发源，来判断DMA通道会接收哪一个事件的触发。比如这里的定时器触发。"><a href="#DMA触发可以通过设置DMA的触发源，来判断DMA通道会接收哪一个事件的触发。比如这里的定时器触发。" class="headerlink" title="DMA触发可以通过设置DMA的触发源，来判断DMA通道会接收哪一个事件的触发。比如这里的定时器触发。"></a>DMA触发可以通过设置DMA的触发源，来判断DMA通道会接收哪一个事件的触发。比如这里的定时器触发。</h4><!--定时器1是CC2530中功能最全的一个定时/计数器，是在应用中被优先选用的对象。--><h3 id="（4）定时器T1的运行模式"><a href="#（4）定时器T1的运行模式" class="headerlink" title="（4）定时器T1的运行模式"></a>（4）定时器T1的运行模式</h3><p> 定时器T1运行模式有多种，不同的运行模式有不同的功能。本次试验只涉及到自由运行模式。自由运行模式下，计数器从0x0000开始，每个活动时钟边沿增加1。当计数器达到0xFFFF会产生自动溢出，然后计数器自动载入0x0000，继续递增计数，当达到最终数值0xFFFF产生溢出。当产生溢出之后，相应的寄存器会自动产生溢出标志。</p><p>Ps：定时器1具有一个十六位的计数器，计数器具备运行模式。</p><h3 id="（5）所涉及到的寄存器"><a href="#（5）所涉及到的寄存器" class="headerlink" title="（5）所涉及到的寄存器"></a>（5）所涉及到的寄存器</h3><h4 id="1）T1CTL（控制寄存器）"><a href="#1）T1CTL（控制寄存器）" class="headerlink" title="1）T1CTL（控制寄存器）"></a>1）T1CTL（控制寄存器）</h4><p>定时器T1的控制寄存器T1CTL是一个八位寄存器。它的主要功能时选择定时器T1的工作模式和分频器频率划分。</p><p>它的第0位和第1位是用来设置定时器T1的模式。定时器操作模式通过下列方式设置：</p><p> 00：暂停运行。</p><p> 01：自由运行，从0x0000到0xFFF反复计数。</p><p> 10：模计数，从0x0000到TICCO反复计数。</p><p> 11：正计数/倒计数，从0x0000到T1CC0反复计数且从T1CC0倒计数到0x0000。</p><p>它的第2位和第3位用来设置分频器划分值。产生主动的时钟边缘用来更新计数器，如下：</p><p>00：标记频率/1</p><p>01：标记频率/8</p><p>10：标记频率/32</p><p>11：标记频率/128</p><p>它的第4位到第7位保留。</p><h4 id="2）T1STAT（状态寄存器）"><a href="#2）T1STAT（状态寄存器）" class="headerlink" title="2）T1STAT（状态寄存器）"></a>2）T1STAT（状态寄存器）</h4><p>定时器1的状态寄存器T1STAT是一个八位寄存器。只负责定时器1中断标志，包括定时器溢出中断标志和定时器1通道0~4的中断标志。</p><p>它的第0位到第4位为通道0~通道4的中断标志，第5位为溢出标志位，当计数器达到计数终值自动置1。</p><p>D0：定时器1通道0中断标志位</p><p>D1：定时器1通道1中断标志位</p><p>D2：定时器1通道2中断标志位</p><p>D3：定时器1通道3中断标志位</p><p>D4：定时器1通道4中断标志位</p><p>D5：定时器溢出中断标志位</p><p>D7：未用</p><p>D8:未用</p><h4 id="3）IRCON（中断标志位寄存器）"><a href="#3）IRCON（中断标志位寄存器）" class="headerlink" title="3）IRCON（中断标志位寄存器）"></a>3）IRCON（中断标志位寄存器）</h4><p>当定时器1中断发生时设为1并且当CPU向量指向中断服务例程时清除。</p><p>0：无中断请求</p><p>1：有中断请求</p><h3 id="（6）实验源代码"><a href="#（6）实验源代码" class="headerlink" title="（6）实验源代码"></a>（6）实验源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义控制LED灯的端口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 P1_0<span class="comment">//定义LED1为P10口控制</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(uint xms)</span></span>;<span class="comment">//延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_GPIO</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化P1口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_T1</span><span class="params">()</span></span>;                <span class="comment">//初始化定时器T1</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i --)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">587</span>; j &gt;<span class="number">0</span>; j --);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_GPIO</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  P1DIR |= <span class="number">0x03</span>;     <span class="comment">//P1_0定义为输出</span></span><br><span class="line"></span><br><span class="line">  P1INP |= <span class="number">0X01</span>;     <span class="comment">//打开下拉三态输出</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  LED1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LED2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_T1</span><span class="params">()</span> <span class="comment">//系统不配置工作时钟时默认是2分频，即16MHz</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  T1CTL = <span class="number">0x0d</span>;          <span class="comment">//128分频，自动重装 0X0000-0XFFFF </span></span><br><span class="line"></span><br><span class="line">  T1STAT= <span class="number">0x21</span>;          <span class="comment">//通道0, 中断有效   </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  uchar count;</span><br><span class="line"></span><br><span class="line">  Config_GPIO();</span><br><span class="line"></span><br><span class="line">  Config_T1();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(IRCON&gt;<span class="number">0</span>)</span><br><span class="line">   &#123; </span><br><span class="line">      IRCON=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(count++=<span class="number">1</span>)      <span class="comment">//约2s周期性闪烁</span></span><br><span class="line">      &#123;</span><br><span class="line">       count=<span class="number">0</span>;</span><br><span class="line">       LED1 = !LED1;        <span class="comment">//LED1闪烁        </span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（7）对代码的解释"><a href="#（7）对代码的解释" class="headerlink" title="（7）对代码的解释"></a>（7）对代码的解释</h3><p>  首先是一些命令行，然后就是一函数的声明。这里有三个函数，分别是延时函数、灯初始化函数和定时器初始化函数。前面两个函数都不是重点，关键是定时器初始化函数。我们只是将将灯作为我们实验的一个现象展示，让我们对定时器有一个深入的了解，以后它将作为一个模块应用到其他的场景中，比如通过定时器来控制某一个物体的开关。这里的定时器初始化函数中只有两行代码。T1CTL = 0x0d; 它表示我们这个定时器的工作模式是自由运行模式，工作频率为128分频，至于它的值是怎么来的呢？我们前面讲过，T1CTL控制寄存器它是一个八位寄存器，它的第0位和第1位是控制定时器的工作模式的，当为01表示的是自由运行模式，我们本次试验涉及的就是自由运行模式，所以低两位为01，而它的第3位和第4位是控制定时器分频的，当为11时表示的是128分频，所以T1CTL的低四位是1101，高四位保留即为0000，所以转化为十六进制为0x0d。<!--T1STAT=0x21；它表示的是通道0中断有效。试验证明其实这一个设置要不要都不影响。-->紧接着就是主函数，其实我们应该是从主函数开始讲解。首先定义一个无符号的字符类型变量count，它作为整数使用的话范围是从0到255，默认值是0。该变量在计算总时间的一个公式中会用到。然后就是初始化函数，完了后进入到一个无限循环，while循环中首先用if语句判断一下是否有中断请求，有的话表明寄存器IRCON的值为1，此时将它置为0。</p><p>然后执行下一个if语句，判断count的值，count的值应该是记录计时器达到0xFFFF的次数。然后count究竟能处在一个什么样的范围内，就取决于你想让他间隔多长时间闪烁一次。这里是count的值等于1。if条件成立，执行下一步将count置零，紧接着改变灯的转态。第二个if语句也可以用一个延时函数来代替。</p><p>对于main函数的解析</p><p>计数器计满一次 </p><p>Ps：系统在不配置工作频率时默认为 2 分频，即32M/2=16M，所以定时器每次溢出时T=1/(16M/128)<em>65536≈0.5s, 所以总时间Ta=T</em>count=0.5*1=0.5S切换 1 次状态。所以看起来是 1S 闪烁 1 次。注意 闪烁的意思是亮-灭。</p><h2 id="2、利用定时器T3中断方式控制LED1状态周期性改变"><a href="#2、利用定时器T3中断方式控制LED1状态周期性改变" class="headerlink" title="2、利用定时器T3中断方式控制LED1状态周期性改变"></a><strong>2、利用定时器T3中断方式控制LED1状态周期性改变</strong></h2><h3 id="（1）定时器T3的介绍"><a href="#（1）定时器T3的介绍" class="headerlink" title="（1）定时器T3的介绍"></a>（1）定时器T3的介绍</h3><h4 id="1）定时器3的运行模式"><a href="#1）定时器3的运行模式" class="headerlink" title="1）定时器3的运行模式"></a>1）定时器3的运行模式</h4><p>定时器3是一个八位寄存器，它有两个独立独立的比较/捕获通道，每个通道上使用一个I/O引脚。它还具有一个8位的计数器，提供定时和计数功能。计数器有4种运行模式：自由运行模式、倒计数模式、模计数模式和正/倒计数模式。本次试验用到的是自由运行模式，定时器的计数器从0x00开始，在每个时钟活动的边沿递增，当计数器达到0xFF，计数器将重装载入0x00。如果设置了中断，当达到最终计数值0xFF时，将产生一个中断请求。</p><h4 id="2）定时器通道"><a href="#2）定时器通道" class="headerlink" title="2）定时器通道"></a>2）定时器通道</h4><p>定时器3有两个通道，通道0和通道1，每个通道的模式是由控制和状态寄存器来控制的，设置模式包括捕获模式和输出比较模式。当通道配置为输入捕获模式时，通道相关的I/O引脚配置为一个输入。定时器启动之后，输入引脚上的一个上升沿、下降沿或任何边沿都会触发一个捕获，即捕获8位计数器内容到相关的通道捕获寄存器中，因此定时器能够捕获一个外部事件发生的时间。它的每一次捕获可以作为一个触发中断事件。当通道配置为输出比较模式，通道相关的I/O引脚必须设置为输出。定时器启动之后，将对比计数器的内容和通道比较寄存器的内容。</p><h4 id="3）定时器中断"><a href="#3）定时器中断" class="headerlink" title="3）定时器中断"></a>3）定时器中断</h4><p>定时器3有一个中断向量，当触发中断事件发生时，将产生一个中断请求，有下列几种触发中断事件：</p><p>计数器达到最终计数值；</p><p>比较事件；</p><p>捕获事件。</p><p>Ps：所有涉及到中断的实验应当都是首先有一个触发中断事件，然后由中断向量产生一个中断请求，紧接着转去处理中断。</p><h3 id="（2）相关寄存器的配置"><a href="#（2）相关寄存器的配置" class="headerlink" title="（2）相关寄存器的配置"></a>（2）相关寄存器的配置</h3><h4 id="1）控制寄存器T3CTL（八位寄存器）"><a href="#1）控制寄存器T3CTL（八位寄存器）" class="headerlink" title="1）控制寄存器T3CTL（八位寄存器）"></a>1）控制寄存器T3CTL（八位寄存器）</h4><p>定时器3控制寄存器T3CTL主要负责定时器的分频器的划分、定时器的停止/运行、定时器的中断设置、定时器的计数器清除、定时器的功能模式选择。</p><p>从高位到地位：</p><p>7~5：负责分频器划分值。</p><p>000：标记频率/1</p><p>001：标记频率/2</p><p>010：标记频率/4</p><p>011：标记频率/8</p><p>100：标记频率/16</p><p>101：标记频率/32</p><p>110：标记频率/64</p><p>111：标记频率/128</p><p>4:负责启动定时器。</p><p>3：负责溢出中断屏蔽。</p><p>0：中断禁止</p><p>1：中断使能</p><p>2：负责清除计数器。</p><p>0~1：负责选择定时器的模式。</p><p>00：自由运行模式</p><p>01：倒计数模式</p><p>10：模计数模式</p><p>11：正计数/倒计数模式</p><h3 id="3-相关代码"><a href="#3-相关代码" class="headerlink" title="(3)相关代码"></a>(3)相关代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义控制LED灯的端口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 P1_0  <span class="comment">//定义LED1为P10口控制</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">uint count;<span class="comment">//用于定时器计数</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i --)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">587</span>; j &gt;<span class="number">0</span>; j --);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_GPIO</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  P1DIR |= <span class="number">0x03</span>;     <span class="comment">//P1_0定义为输出</span></span><br><span class="line"></span><br><span class="line">  P1INP |= <span class="number">0X01</span>;     <span class="comment">//打开下拉三态输出</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  LED1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LED2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_T3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line"></span><br><span class="line">  T3CTL |= <span class="number">0x08</span> ;            <span class="comment">//开溢出中断     </span></span><br><span class="line"></span><br><span class="line">  T3IE = <span class="number">1</span>;                  <span class="comment">//开总中断和T3中断</span></span><br><span class="line"></span><br><span class="line">  T3CTL|=<span class="number">0XE0</span>;               <span class="comment">//128分频,128/16000000*N=0.5S,N=65200</span></span><br><span class="line"></span><br><span class="line">  T3CTL &amp;= ~<span class="number">0X03</span>;            <span class="comment">//自动重装 00－&gt;0xff  65200/256=254(次)</span></span><br><span class="line"></span><br><span class="line">  T3CTL |=<span class="number">0X10</span>;              <span class="comment">//启动</span></span><br><span class="line"></span><br><span class="line">  EA = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  Config_GPIO();<span class="comment">//调用初始化函数</span></span><br><span class="line"></span><br><span class="line">  Config_T3();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">pragma</span> vector = T3_VECTOR <span class="comment">//定时器T3</span></span></span><br><span class="line"></span><br><span class="line"> __<span class="function">interrupt <span class="keyword">void</span> <span class="title">T3_ISR</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">    IRCON = <span class="number">0x00</span>;                  <span class="comment">//清中断标志, 也可由硬件自动完成 </span></span><br><span class="line">    <span class="keyword">if</span>(++count&gt;<span class="number">254</span>)                <span class="comment">//254次中断后LED取反，闪烁一轮（约为0.5s) </span></span><br><span class="line">    &#123;          </span><br><span class="line">      count = <span class="number">0</span>;                    <span class="comment">// 计数清零 </span></span><br><span class="line">      LED1=~LED1;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h2><h3 id="CC2530定时-计数器的工作模式"><a href="#CC2530定时-计数器的工作模式" class="headerlink" title="CC2530定时/计数器的工作模式"></a><strong>CC2530定时/计数器的工作模式</strong></h3><p>（1）自由运行模式 </p><p><img src="https://i.loli.net/2018/12/18/5c18fe62e1710.png" alt="img"> </p><p>在自由运行模式下，计数器从0x0000开始，在每个活动时钟边沿增加1，当计数器达到0xFFFF时溢出，计数器重新载入0x0000并开始新一轮递增计数 </p><p>自由运行模式最大为FFFF也就是65535</p><p>自由运行模式的计数周期是固定值0xFFFF，当计数器达到最终计数值0xFFFF时，</p><p>系统自动设置标志位IRCON.T1IF和T1STAT.OVFIF，—— 用于查询</p><p>如果用户设置了相应的中断屏蔽位TIMIF.T1OVFIM和IEN1.T1EN，——用于中断请求。</p><p>（2）模模式</p><p><img src="https://i.loli.net/2018/12/18/5c18fe895adab.png" alt="img"><br>    在模模式下，计数器从0x0000开始，在每个活动时钟边沿增加1，当计数器达到T1CC0寄存器保存的值时溢出，计数器将复位到0x0000并开始新一轮递增计数。</p><p>计数溢出后，将置位相应标志位，同时如果设置了相应的中断使能则会产生一个中断请求。T1CC0由2个8位寄存器T1CC0H和T1CC0L构成，分别用来保存最终计数值的高8位和低8位。模模式的计数周期不是固定值，可由用户自行设定，以便获取不同时长的定时时间。 </p><p>定时器3和定时器4的倒计数模式类似与模模式，只不过计数值是从最大计数值向0x00倒序计数。</p><p>（3）正计数/倒计数模式</p><p><img src="https://i.loli.net/2018/12/18/5c18fea16b202.png" alt="img"><br>    在正计数/倒计数模式下，计数器反复从0x0000开始，正计数到T1CC0保存的最终计数值，然后再倒计时回0x0000。</p><p>正计数/倒计数模式下，计数器在到达最终计数值时溢出，并置位相关标志位，若用户已使能相关中断，则会产生中断请求。这种工作模式在用来进行PWM控制时可以实现中心对齐的PWM输出。</p><h3 id="单片机中的定时-计数器一般具有以下功能："><a href="#单片机中的定时-计数器一般具有以下功能：" class="headerlink" title="单片机中的定时/计数器一般具有以下功能："></a><strong>单片机中的定时/计数器一般具有以下功能：</strong></h3><h4 id="1）定时器功能"><a href="#1）定时器功能" class="headerlink" title="1）定时器功能"></a>1）定时器功能</h4><p>对规定时间间隔的输入信号的个数进行计数，当计数值达到指定值时，说明定时时间已到。这是定时/计数器的常用功能，可用来实现延时或定时控制，其输入信号一般使用单片机内部的时钟信号。 </p><h4 id="2）计数器功能"><a href="#2）计数器功能" class="headerlink" title="2）计数器功能"></a>2）计数器功能</h4><p>对任意时间间隔的输入信号的个数进行计数。一般用来对外界事件进行计数，其输入信号一般来自单片机外部开关型传感器，可用于生产线产品计数、信号数量统计和转速测量等方面。 </p><h4 id="3）捕获功能"><a href="#3）捕获功能" class="headerlink" title="3）捕获功能"></a>3）捕获功能</h4><p>对规定时间间隔的输入信号的个数进行计数，当外界输入有效信号时，捕获计数器的计数值。通常用来测量外界输入脉冲的脉宽或频率，需要在外界输入信号的上升沿和下降沿进行两次捕获，通过计算两次捕获值的差值可以计算出脉宽或周期等信息。 </p><h4 id="4）比较功能"><a href="#4）比较功能" class="headerlink" title="4）比较功能"></a>4）比较功能</h4><p>当计数值与需要进行比较的值相同时向CPU提出中断请求或改变I/O口输出电平等操作。一般用于控制信号输出。 </p><h4 id="5）PWM输出功能"><a href="#5）PWM输出功能" class="headerlink" title="5）PWM输出功能"></a>5）PWM输出功能</h4><p>对规定时间间隔的输入信号的个数进行计数，根据设定的周期和占空比从I/O口输出控制信号。一般用来控制LED灯亮度或电机转速。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><p>【1】 设置定时器的分频系数，工作模式</p><p>【2】 [设置定时器1最大计数值]</p><p>【3】 使能定时器1相关中断</p><p>【4】 EA</p>]]></content>
      
      <categories>
          
          <category> Zigbee基础部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>外部中断</title>
      <link href="/2018/12/18/%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
      <url>/2018/12/18/%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
      <content type="html"><![CDATA[<p>熟悉外部中断相关实验</p><a id="more"></a><h2 id="1、什么是外部中断"><a href="#1、什么是外部中断" class="headerlink" title="1、什么是外部中断"></a><strong>1、什么是外部中断</strong></h2><p>中断其实就是机器收到信号后，放下正在处理的任务，来处理你设定好的中断函数。CC2530按键外部中断，通过按键产生中断，进入中断函数，实现基本的中断控制。这种中断方式是基本的I/O中断。</p><h2 id="2、通用I-O中断"><a href="#2、通用I-O中断" class="headerlink" title="2、通用I/O中断"></a><strong>2、通用I/O中断</strong></h2><p>CC2530的CPU有18个中断源，每个中断源都由一系列的SFR寄存器进行控制。每个中断都可以分别使能和控制（中断使能寄存器IEN0、IEN1、IEN2）（0:中断禁止1：中断使能）。通用I/O引脚在设置为输入后，可以用于产生中断。并且通用I/O中断还可以设置其触发方式。通用I/O中断在P0、P1、P2三个端口都可以产生，在设置其中断时需要将其要发生中断引脚的使能位置1。</p><p>中断使能：让中断可以被触发，可以进入中断服务程序。</p><p>中断禁止：即使中断信号来了也不会触发中断，也就不会进入中断服务程序。</p><h2 id="3、中断优先级"><a href="#3、中断优先级" class="headerlink" title="3、中断优先级"></a><strong>3、中断优先级</strong></h2><p>为使系统能及时响应并处理发生的所有中断，系统根据引起中断事件的重要性和紧迫程度，硬件将中断源分为若干个级别，称作中断优先级。本次试验中，仅仅涉及到了通过按键产生中断信号，不需考虑优先级。</p><h2 id="4、中断涉及到的寄存器"><a href="#4、中断涉及到的寄存器" class="headerlink" title="4、中断涉及到的寄存器"></a>4、<strong>中断涉及到的寄存器</strong></h2><h3 id="（1）中断使能寄存器"><a href="#（1）中断使能寄存器" class="headerlink" title="（1）中断使能寄存器"></a><strong>（1）中断使能寄存器</strong></h3><h4 id="1）IEN1（八位寄存器）"><a href="#1）IEN1（八位寄存器）" class="headerlink" title="1）IEN1（八位寄存器）"></a>1）IEN1（八位寄存器）</h4><p>中断使能寄存器IEN1控制P0端口、定时器1~4、和DMA中断的使能和禁止，如果使某一位中断使能，只需要将IEN1中对应的“位”设置为1即可；如果将中断禁止，只需要将其设置为0即可。比如，IEN1使能寄存器的第五位P0IE用来设置端口P0使能。</p><p>例：IEN1中断设置</p><p>/<em>设置P0端口中断使能</em>/</p><p>IEN1|=0x20；</p><h4 id="2）IEN2（八位寄存器）"><a href="#2）IEN2（八位寄存器）" class="headerlink" title="2）IEN2（八位寄存器）"></a><strong>2）IEN2（八位寄存器）</strong></h4><p>中断使能寄存器IEN2控制看门狗定时器、P1端口、串口发送、P2端口、RF中断的使能和禁止，如果使某一位中断使能，只需要将IEN2中对应的“位”设置为1即可；如果将中断禁止，只需要将其设置为0即可。比如，IEN2使能寄存器的第四位P1IE用来设置端口P1使能；第一位P2IE用来设置端口P2使能。</p><p>例：IEN2使能设置</p><p>/<em>设置P1和P2端口中断使能</em>/</p><p>IEN2|=0x12；</p><h4 id="3）PxIEN"><a href="#3）PxIEN" class="headerlink" title="3）PxIEN"></a><strong>3）PxIEN</strong></h4><p>IEN1和IEN2寄存器设置端口中断时，是将P0、P1和P2所有端口的引脚全部设置为中断使能。比如设置P0端口中断使能，实质上是设置了P0_0~P0_7所有的输入引脚中断使能，如果要单独设置某一引脚中断使能，除了设置IENx（x的取值为0和1）还需要设置PxIEN寄存器（x的取值为0、1、2）。PxIEN中断使能寄存器可以单独配置端口的某一引脚中断使能禁止。</p><h4 id="4）P0IEN（八位寄存器）"><a href="#4）P0IEN（八位寄存器）" class="headerlink" title="4）P0IEN（八位寄存器）"></a>4）P0IEN（八位寄存器）</h4><p>中断使能寄存器P0IEN控制P0端口P0_0~P0_7引脚的中断禁止和使能，如果要使某一特定引脚中断使能或禁止，只需要在P0IEN中将相应的“位”设置为0或1即可。</p><p>例：设置P0_5引脚中断使能</p><p>/<em>设置P0_5中断使能</em>/</p><p>P0IEN|=0x20；</p><p>/<em>设置P0端口中断使能</em>/</p><p>IEN|=0x20;</p><h4 id="5）IEN0（八位寄存器）"><a href="#5）IEN0（八位寄存器）" class="headerlink" title="5）IEN0（八位寄存器）"></a><strong>5）IEN0（八位寄存器）</strong></h4><p>通用I/O中断在设置完引脚之后，需要开启CC2530总中断，总中断EA位于中断使能寄存器IEN0的第七位，此位决定CC2530所有中断的使能和禁止。通用I\O在设置完成引脚中断之后，需要将EA的总中断打开。</p><p>例：EA设置</p><p>/<em>打开总中断</em>/</p><p>EA=1；</p><h3 id="（2）中断触发方式寄存器"><a href="#（2）中断触发方式寄存器" class="headerlink" title="（2）中断触发方式寄存器"></a>（2）<strong>中断触发方式寄存器</strong></h3><p>通用I\O在作为中断使用时，可以配置其中断触发方式由寄存器PICTL来设置，其触发方式分为上升沿触发方式和下降沿触发方式。中断触发方式寄存器可以控制P0端口、P1端口和P2端口的触发方式，比如中断触发方式寄存器的第零位用来设置端口0的P0.0~</p><p>P0.7输入模式下的中断配置，该位为所有端口0的输入P0.0~P0.7选择中断请求条件。0：输入的上升沿引起中断；1：输入的下降沿引起中断。</p><p>例：PICTL中断设置</p><p>/<em>设置P0_5下降沿触发中断</em>/</p><p>PICTL|=0x01</p><h3 id="（3）中断标志寄存器"><a href="#（3）中断标志寄存器" class="headerlink" title="（3）中断标志寄存器"></a><strong>（3）中断标志寄存器</strong></h3><h4 id="1）PxIFG"><a href="#1）PxIFG" class="headerlink" title="1）PxIFG"></a>1）PxIFG</h4><p>I/O中断发生后，中断标志寄存器的相应位会自动置1。在中断处理函数中判断是否有中断发生只需要判断寄存器PxIFG（其中x的取值为0、1、2）的值是否大于0，或者是PxIFG的某一位是否大于0即可。</p><h4 id="2）P0IFG（八位寄存器）"><a href="#2）P0IFG（八位寄存器）" class="headerlink" title="2）P0IFG（八位寄存器）"></a>2）P0IFG（八位寄存器）</h4><p>如果在P0端口有中断发生，但不需要判断具体是哪一引脚发生中断是，在判断中断标志时只需要判断P0IFG是否大于0即可。</p><p>例：中断标志判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*判断端口P0是否发生中断*/</span><br><span class="line"></span><br><span class="line">if（P0IFG&gt;0）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要判断是否某一引脚发生中断，则需要判断PxIFG寄存器中相应的“位”是否置1.</p><p>例：中断标志判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//判断P0_5是否发生中断</span><br><span class="line">If（P0IFG&amp;0x20&gt;0）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、实验现象"><a href="#5、实验现象" class="headerlink" title="5、实验现象"></a>5、实验现象</h2><p>依次按下按键S1控制LED1的亮和灭</p><h2 id="6、相关代码"><a href="#6、相关代码" class="headerlink" title="6、相关代码"></a>6、相关代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义控制LED灯的端口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 P1_0<span class="comment">//定义LED1为P1.0口控制</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1 P0_0<span class="comment">//中断口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delayms</span><span class="params">(uint)</span></span>;<span class="comment">//延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeyInit</span><span class="params">()</span></span>;<span class="comment">//按键初始化</span></span><br><span class="line"></span><br><span class="line">uchar KeyValue=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delayms</span><span class="params">(uint xms)</span><span class="comment">//i=xms即延时i毫秒</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">uint i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=xms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">587</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LED初始化程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_IO</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">P1DIR|=<span class="number">0x01</span>;<span class="comment">//P1_0定义为输出</span></span><br><span class="line"></span><br><span class="line">P1INP|=<span class="number">0X01</span>;</span><br><span class="line"></span><br><span class="line">LED1=<span class="number">0</span>;<span class="comment">//LED1灯熄灭</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY初始化程序--外部中断方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_Key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">P0IEN|=<span class="number">0X01</span>;<span class="comment">//P00设置为中断方式</span></span><br><span class="line"></span><br><span class="line">IEN1|=<span class="number">0X20</span>;<span class="comment">//允许P0口中断;</span></span><br><span class="line"></span><br><span class="line">PICTL|=<span class="number">0x01</span>;<span class="comment">//下降沿触发</span></span><br><span class="line"></span><br><span class="line">P0IFG=<span class="number">0x00</span>;<span class="comment">//初始化中断标志位</span></span><br><span class="line"></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//开CC2530总中断</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//格式：#pragma vector = 中断向量，紧接着是中断处理程序</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = P0INT_VECTOR</span></span><br><span class="line"></span><br><span class="line">__<span class="function">interrupt <span class="keyword">void</span> <span class="title">P0_ISR</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//两个下划线</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Delay(<span class="number">10</span>);            <span class="comment">//去除抖动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KEY1==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">LED1=~LED1;             <span class="comment">//改变LED1状态</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P0IFG = <span class="number">0</span>;             <span class="comment">//清中断标志 </span></span><br><span class="line"></span><br><span class="line">P0IF = <span class="number">0</span>;             <span class="comment">//清中断标志 </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Config_IO();<span class="comment">//调用初始化函数</span></span><br><span class="line"></span><br><span class="line">Config_Key();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、对代码的解释"><a href="#6、对代码的解释" class="headerlink" title="6、对代码的解释"></a>6、对代码的解释</h2><p>上述代码，主函数中只有三行语句，感觉好像没有用到中断函数，但其实是用到了的。所谓外部中断就是当接收到中断信号，就去处理中断即执行中断函数。一开始，程序运行到while（1）这个地方，在没有接收按键中断信号之前，它会一直停在那里。然后这时候按下按键S1后，表明中断信号已产生。然后程序就会停下当前的任务即一直进行while循环转去执行中断处理程序。然后执行完后回来继续while循环。</p><p>还有对于该实验中的中断处理函数，需要注意的一点就是中断处理函数有很多种写法，有些地方可能会在一开始进行一个if语句的判断，来检测是否有中断产生，这里没有这样写。但是它一样能完成这样的一个中断处理。所以代码不需要去纠结，只要会用即可。还有这里的中断函数中有：</p><p>P0IFG=0;//清中断标志</p><p>P0IF=0;//清中断标志</p><p>可能会有这样的一个想法：这两句是不是有些重复。其实不然，P0IF是清P0端口中断标志，而P0IFG是清P0端口具体某一位的中断标志。而且这两句少了其中任一句都不行（实验现象：当你按下按键后，灯会一直闪烁一直闪烁）。如果将这两句的位置调换一下也会影响实验现象（实验现象：一段时间，按下按键一次后，灯会亮一下然后保持灭的状态；一段时间，按下按键一次后，灯会灭一下然后保持亮的状态。）</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h2><p>学会根据手册来查看需要配置的寄存器</p><p>下图为cc2530datashet-38文件的部分内容</p><p>以P0_0口中断为例</p><p><img src="https://i.loli.net/2018/12/18/5c18fc17d1545.png" alt="img"> </p><p>由图可知 需要配置的是PICTL.P0ICON  P0IEN P0IE 以及EA </p><p>中断标志位为 P0IFG P0IF</p><p>之后去查手册 文件名为CC253X用户指南 搜索需要的寄存器</p>]]></content>
      
      <categories>
          
          <category> Zigbee基础部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>按键实验</title>
      <link href="/2018/12/18/%E6%8C%89%E9%94%AE%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/12/18/%E6%8C%89%E9%94%AE%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>熟悉按键相关实验</p><a id="more"></a><h3 id="1、通过按下按键S1来控制LED1的亮灭"><a href="#1、通过按下按键S1来控制LED1的亮灭" class="headerlink" title="1、通过按下按键S1来控制LED1的亮灭"></a>1、通过按下按键S1来控制LED1的亮灭</h3><p><img src="https://i.loli.net/2018/12/18/5c18f73cc3fe8.png" alt=""></p><h3 id="1）现象："><a href="#1）现象：" class="headerlink" title="1）现象："></a><strong>1）现象：</strong></h3><p>LED1不亮的时候，当你按下S1并松手后，LED1就亮了。</p><p>LED1不亮的时候，当你按下S1不松手，LED1仍不会亮。</p><p>LED1亮的时候，当你按下S1并松手后，LED1就灭了。</p><p>LED1亮的时候，当你按下S1不松手，LED1仍不会灭。</p><h3 id="2）代码："><a href="#2）代码：" class="headerlink" title="2）代码："></a>2）代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义控制LED灯的端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 P1_0 <span class="comment">//LED1为P1.0口控制</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1 P0_0  <span class="comment">//KEY1为P0.0口控制</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line">void Delay(uint)； //延时函数</span><br><span class="line">uchar KeyScan()；       //按键扫描程序</span><br><span class="line"> </span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = k； i &gt; <span class="number">0</span>； i --)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">587</span>； j &gt;<span class="number">0</span>； j --)；</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_IO</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">P1DIR |= <span class="number">0x01</span>；     <span class="comment">//P1_0定义为输出        /**************</span></span><br><span class="line">                                           <span class="comment">//*配置LED的IO口</span></span><br><span class="line">P1INP |= <span class="number">0X01</span>；     <span class="comment">//打开下拉              **************/</span></span><br><span class="line"></span><br><span class="line">P0SEL &amp;= ~<span class="number">0X01</span>；    <span class="comment">//设置P00为普通IO口          /**************               </span></span><br><span class="line">P0DIR &amp;= ~<span class="number">0X01</span>；    <span class="comment">//按键在P00口，设置为输入模式 *配置KEY的IO口        </span></span><br><span class="line">P0INP &amp;= ~<span class="number">0x01</span>；    <span class="comment">//打开P00上拉电阻,不影响       **************/             </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//按键检测函数</span></span><br><span class="line">uchar KeyScan(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      Delay(<span class="number">10</span>)；</span><br><span class="line">      <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(!KEY1)；  <span class="comment">//松手检测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>；      <span class="comment">//有按键按下</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；           <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">主函数</span><br><span class="line"><span class="keyword">void</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">Config_IO()；</span><br><span class="line">LED1=<span class="number">0</span>；</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(KeyScan())       <span class="comment">//按键改变LED状态</span></span><br><span class="line">    LED1=~LED1；     </span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）对部分代码的解释"><a href="#3）对部分代码的解释" class="headerlink" title="3）对部分代码的解释"></a><strong>3）对部分代码的解释</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A）</span><br><span class="line">uchar KeyScan()；    //按键扫描程序</span><br><span class="line"></span><br><span class="line"><span class="function">uchar <span class="title">KeyScan</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">     Delay(<span class="number">10</span>)；</span><br><span class="line">      <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(!KEY1)；  <span class="comment">//松手检测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>；      <span class="comment">//有按键按下</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；           <span class="comment">//无按键按下</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      上述的按键扫描程序中，函数体内体用了两个if语句即if嵌套语句，中间用了Delay函数。这样做的目的是为防止“鬼影”，专业术语：去抖动。举一个例子：有一扇门，我们现在要检测是否有人痛过这扇门。在某一个时刻，我们开始检测，有一个人正要准备这扇门，注意只是正准备痛过而还没有痛过也就是这一时刻检测员没有检测到，于是记录下没有人通过的结果。但是在这时刻的下一秒这个人就通过了这扇门。因此，该检测员记录的结果不对。如果检测员多等一会儿，就可以检测到结果。接下来，Key==1表示手在按键上（这里默认为有力的作用），Key==0表示手离开了按键。而while（！Key）；也是为了多次确保手已离开了按键。这两步共同决定了是否有按键按下。这个按键扫描程序也很好地解释了一开始的四种现象。</p><h3 id="2、通过按下按键S1来控制LED1的亮灭，通过按下按键S2来控制LED2的亮灭。"><a href="#2、通过按下按键S1来控制LED1的亮灭，通过按下按键S2来控制LED2的亮灭。" class="headerlink" title="2、通过按下按键S1来控制LED1的亮灭，通过按下按键S2来控制LED2的亮灭。"></a><strong>2、通过按下按键S1来控制LED1的亮灭，通过按下按键S2</strong>来控制LED2的亮灭。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）相关的代码：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义控制LED灯的端口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 P1_0 <span class="comment">//LED1为P1.0口控制</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1 P0_0      <span class="comment">//KEY1为P0.0口控制</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2 P1_1 <span class="comment">//LED2为P1_0口控制</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY2 P0_1     <span class="comment">//KEY2为P0_1口控制</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line">void Delay(uint)； //延时函数</span><br><span class="line"></span><br><span class="line">uchar KeyScan1()；            //按键扫描程序</span><br><span class="line"></span><br><span class="line">uchar KeyScan2()；            //按键扫描程序</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">延时函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delayms</span><span class="params">(uint xms)</span>   <span class="comment">//i=xms 即延时i毫秒</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> uint i,j；</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=xms；i&gt;<span class="number">0</span>；i--)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">587</span>；j&gt;<span class="number">0</span>；j--)；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      LED初始化函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLed</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  P1DIR |= <span class="number">0x03</span>；    <span class="comment">//P1_0、P1_1定义为输出</span></span><br><span class="line"></span><br><span class="line">  P1INP |= <span class="number">0X01</span>；  </span><br><span class="line"></span><br><span class="line">  LED1 = <span class="number">0</span>；         <span class="comment">//LED1灯熄灭</span></span><br><span class="line"></span><br><span class="line">  LED2 = <span class="number">0</span>；         <span class="comment">//LED2灯熄灭</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     按键初始化函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InitKey()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  P0SEL &amp;= ~<span class="number">0X01</span>；    <span class="comment">//设置P00为普通IO口  </span></span><br><span class="line"></span><br><span class="line">  P0DIR &amp;= ~<span class="number">0X03</span>；    <span class="comment">//按键在P00、P01口，设置为输入模式</span></span><br><span class="line"></span><br><span class="line">  P0INP &amp;= ~<span class="number">0x01</span>；    <span class="comment">//打开P00上拉电阻,不影响</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     按键检测函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"></span><br><span class="line">uchar KeyScan1(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  &#123;Delayms(<span class="number">10</span>)；</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!KEY1)；  <span class="comment">//松手检测</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>；      <span class="comment">//有按键按下</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；           <span class="comment">//无按键按下</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">uchar KeyScan2(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  &#123;Delayms(<span class="number">10</span>)；</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!KEY2)；  <span class="comment">//松手检测</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>；      <span class="comment">//有按键按下</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；           <span class="comment">//无按键按下</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      主函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main(<span class="keyword">void</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  InitLed()； <span class="comment">//调用初始化函数</span></span><br><span class="line"></span><br><span class="line">  InitKey()；</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(KeyScan1())      <span class="comment">//按键改变LED1状态</span></span><br><span class="line"></span><br><span class="line">    LED1=~LED1；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(KeyScan2())     <span class="comment">//按键改变LED2状态</span></span><br><span class="line"></span><br><span class="line">    LED2=~LED2；</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h3><p>对按键检测函数KeyScan()的理解，以及里面的去抖动操作。上面已经讲的很清楚。</p><p>进一步加深对配置寄存器的操作的印象</p>]]></content>
      
      <categories>
          
          <category> Zigbee基础部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点亮第一个LED</title>
      <link href="/2018/12/18/%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AALED/"/>
      <url>/2018/12/18/%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AALED/</url>
      <content type="html"><![CDATA[<p>点亮第一个LED灯以及相关拓展实验</p><a id="more"></a><p>WeBee底板的LED部分原理图 由图可知 LED1由P1_0端口控制，LED2由P1_1端口控制</p><p><img src="https://i.loli.net/2018/12/18/5c18f42699a92.png" alt=""></p><h3 id="1、点亮LED1"><a href="#1、点亮LED1" class="headerlink" title="1、点亮LED1"></a><strong>1、点亮LED1</strong></h3><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LED1  P1_0    <span class="comment">//定义P10口为LED1控制端</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_IO</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">P1DIR |= <span class="number">0x01</span>;     <span class="comment">//P1_0定义为输出</span></span><br><span class="line"></span><br><span class="line">P1INP |= <span class="number">0X01</span>;     <span class="comment">//打开下拉</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line">Config_IO();      <span class="comment">//调用初始化程序</span></span><br><span class="line"></span><br><span class="line">LED1 = <span class="number">1</span>;       <span class="comment">//点亮LED1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   首先，我们的这个实验目的就是要点亮第一个LED，那么我们是通过代码（软件）让硬件工作，而软件是不能直接让硬件工作的，是通过间接方式上。作为这中间桥梁的其实是寄存器，涉及到的寄存器有功能寄存器、方向寄存器和配置寄存器。应当注意的是方向寄存器，它是决定让那个灯亮的依据。代码是高级语言，无法直接控制硬件工作的，的找一个听得懂该语言的东西，这个东西就是寄存器，代码通过操作寄存器简接使硬件工作。</p><p> 在以上代码中，我们可以看到P1DIR |= 0x01; 该句代码中P1DIR的功能就是在选择哪个灯亮。此处它的值是0x01，它是一个十六进制的数。转化为二进制后是八位，则功能寄存器是八位寄存器。0x01=0000 0001。再查看传感器地板，控制LED1的端口是P1_0,因此在程序的最开始要自定义#define LED1 P1_0，在main函数中要设置LED1=1，表示点亮LED1。而八位二进制的最低位是1，其余是0。 </p><h3 id="2、点亮第二个LED2"><a href="#2、点亮第二个LED2" class="headerlink" title="2、点亮第二个LED2"></a>2、点亮第二个LED2</h3><p> 通过对点亮第一个LED1的代码理解后，再结合传感器底板的观察，可知控制LED2的端口是P1_1，因此如果想点亮LED2,则在以上代码中仅将自定义改成#define LED2 P1_1,void Config_IO(void)中将P1DIR的值改为0x02，main（void）中将LED1 = 1改为LED2=1，其余不变。</p><h3 id="3、同时点亮LED1、LED2"><a href="#3、同时点亮LED1、LED2" class="headerlink" title="3、同时点亮LED1、LED2"></a><strong>3、同时点亮LED1、LED2</strong></h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 P1_0    <span class="comment">//定义P10口为LED1控制端</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2 P1_1    <span class="comment">//定义P11口为LED2控制端</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_IO</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">P1DIR |= <span class="number">0x03</span>;     <span class="comment">//P1_0 P1_1定义为输出</span></span><br><span class="line"></span><br><span class="line">P1INP |= <span class="number">0X03</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">LED1 = <span class="number">1</span>;       <span class="comment">//点亮LED1</span></span><br><span class="line"></span><br><span class="line">LED2 = <span class="number">1</span>;       <span class="comment">//点亮LED2</span></span><br><span class="line"></span><br><span class="line">Config_IO();      <span class="comment">//调用初始化程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、循环点亮LED1、LED2"><a href="#4、循环点亮LED1、LED2" class="headerlink" title="4、循环点亮LED1、LED2"></a>4、循环点亮LED1、LED2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioCC2530.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 P1_0    <span class="comment">//定义P10口为LED1控制端</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2 P1_1    <span class="comment">//定义P11口为LED2控制端</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config_IO</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">P1DIR |= <span class="number">0x03</span>;     <span class="comment">//P1_0 P1_1定义为输出</span></span><br><span class="line"></span><br><span class="line">P1INP |= <span class="number">0X03</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i --)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">587</span>; j &gt;<span class="number">0</span>; j --);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Config_IO();      <span class="comment">//调用初始化程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">LED1=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">LED1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LED2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Delay(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">LED2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Zigbee基础部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机械硬盘</title>
      <link href="/2018/09/05/%E7%A1%AC%E7%9B%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/09/05/%E7%A1%AC%E7%9B%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>众所周知，硬盘分为很多种，有SSD,HDD,HHD。 今天我们在这里介绍的就是HDD(机械硬盘)。 </p><a id="more"></a><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>总体来说，硬盘结构包括：盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器、接口、缓存等几个部份。</p><p> <img src="https://i.loli.net/2018/09/05/5b8f995db3a15.jpg" alt=""></p><p>所有的盘片（一般硬盘里有多个盘片，盘片之间平行）都固定在一个主轴上。在每个盘片的存储面上都有一个磁头，磁头与盘片之间的距离很小（所以剧烈震动容易损坏），磁头连在一个磁头控制器上，统一控制各个磁头的运动。磁头沿盘片的半径方向动作，而盘片则按照指定方向高速旋转，这样磁头就可以到达盘片上的任意位置了。 </p><h2 id="磁盘术语"><a href="#磁盘术语" class="headerlink" title="磁盘术语"></a>磁盘术语</h2><p>磁头（head）、 磁道（track）、 柱面（cylinder）、扇区（sector）、 圆盘（platter）。那么这些都代表着什么呢？</p><p> <img src="https://i.loli.net/2018/09/05/5b8f99ce72450.jpg" alt=""></p><p><img src="https://i.loli.net/2018/09/05/5b8f99ebcfbac.jpg" alt=""></p><p>如下图所示，我们把一个圆盘沿着半径切成几个扇形，这就叫做一个扇面，然后我们再沿着磁头的运动把这个原盘画成几个同心圆，每个原形的轨道就叫做一个磁道，然后被扇形和同心圆分离出来的小区域就叫做扇区。</p><p>再看上图,一般都有几个圆盘，每个盘片有上下两面，分别对应一个磁头。每个圆盘上下对应相同位置的扇区组成一个柱面。 <strong>注意，每个扇区的大小为512bytes，这个值是不会改变的。扇区也是我们在分割硬盘时最小单位了。</strong></p><h2 id="缓冲存储器"><a href="#缓冲存储器" class="headerlink" title="缓冲存储器"></a>缓冲存储器</h2><p>硬盘上面含有一个缓冲存储器，这个内存主要可以将硬盘内重使用的数据缓存起来，以加速系统的读取性能。通常这个缓冲存储器越大越好，因为缓冲存储器的速度要比数据从硬盘中被找出来快得多。</p><p><img src="https://i.loli.net/2018/09/05/5b8f9a5faacae.jpg" alt=""></p><p>看右上角有一个64MB Cache，说明这个硬盘有64MB的缓存，目前主流产品可达16MB左右的内存大小。 </p><h2 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h2><p>硬盘的两个单位，扇区（Sector）和柱面（Cylinder），其中每个扇区大小为512bytes。</p><p>那么是不是每个扇区都一样重要呢？其实整块磁盘的第一个扇区特别重要，因为它记录了整块磁盘的重要信息。磁盘的第一个扇区主要记录了两个重要的信息，分别是：</p><blockquote><p>1.主引导分区（Master Boot Record, MBR）：可以安装引导加载程序的地方，有446bytes。</p><p>2.分区表（Partition Table）：记录整块硬盘分区的状态，有64bytes。</p></blockquote><p><strong>MBR是很重要的，因为当系统在开机的时候会主动去读取这个区块的内容，这样系统才会知道你的程序放在哪里且该如何开机</strong>。如果你要安装多重引导的系统，MBR这个区块的管理就非常重要了！</p><p><img src="https://i.loli.net/2018/09/05/5b8f9acd6afc1.jpg" alt=""></p><p>那么分区表又是什么呢？其实你刚刚拿到的整块硬盘就像一根原木，你必须要在这跟原木上面切割出你想要的区段，这个区段才能够再制作成为你想要的家具。如果没有进行切割，那么原木就不能被有效地使用。同样的道理，你必须要针对你的硬盘进行分区，这样硬盘才可以被你使用。</p><h2 id="磁盘分区表（Partition-Table）"><a href="#磁盘分区表（Partition-Table）" class="headerlink" title="磁盘分区表（Partition Table）"></a>磁盘分区表（Partition Table）</h2><p>怎么分区呢？首先你要有一个锯子，然后扔了，别想不开。上面的那个图中有柱面有开始柱面和结束柱面。那是文件系统的最小单位，也就是分区的最小单位。我们就是利用参考柱面号码的方式来处理。在分区表所在的64bytes容量中，总共分为四组记录去，每组记录区记录了该区段的启始与结束的柱面号码。若将硬盘以长条形来看，然后将柱面以柱形图来看，那么那64bytes的记录区段如图所示。</p><p> <img src="https://i.loli.net/2018/09/05/5b8f9b1469573.jpg" alt=""></p><p> 假设上面的硬盘设备文件名为/dev/hda时，那么这四个分区在Linux系统中的设备文件名如下所示，重点在于文件名后面会再接一个数字，这个数字与该分区所在的位置有关。 </p><blockquote><p>P1:/dev/hda1 P2:/dev/hda2 P3:/dev/hda3 P4:/dev/hda4 </p></blockquote><p>上图我们假设硬盘只有400个柱面，共分区成为四个分区，第四个分区所在为第301到400号柱面的范围。当你的操作系统是Windows时，那么第一到第四个分区的代号应该就是C,D,E,F。当你有数据要写入F盘时，你的数据会被写入到这块磁盘的301~400号柱面之间。</p><p>由于分区表就只有64bytes而已，最多只能容纳四个分区，这四个分区被称为主（Primary）或扩展（Extended）分区。</p><p>来整理一下</p><ol><li><strong>其实所谓的“分区”只是针对那个64bytes的分区表机型设置而已。</strong></li><li><strong>硬盘默认的分区表仅能写入四组分区信息。</strong></li><li><strong>这四组分区信息我们称为主（Primary）或扩展（Extended）分区。</strong></li><li><strong>分区的最小单位为柱面（Cylinder）。</strong></li><li><strong>当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理。</strong></li></ol><h2 id="分区详情"><a href="#分区详情" class="headerlink" title="分区详情"></a>分区详情</h2><p>既然分区表只有记录四组数据的空间，那么是否代表我一块硬盘最多只能分区出四个分区？ “Of course not.”</p><p>对电脑稍微有一点了解的人都知道，你可以将一块硬盘分区成十个以上的分区。那么这又是怎么样实现的呢？在Windows/Linux系统中，我们是通过刚才谈到的扩展分区的方式来处理的。扩展分区的想法是：既然第一个扇区所在的分区表只能记录四条数据，那我可否利用额外的扇区来记录更多的分区信息？如图所示。</p><p><img src="https://i.loli.net/2018/09/05/5b8f9bcf42369.jpg" alt=""></p><p>在图中，我们硬盘四个分区记录仅仅使用了两个，P1为主分区，而P2则为扩展分区。<strong>注意，扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化</strong>。然后我们可以通过扩展分区所指向的那个区块继续作分区的记录。</p><p>图中右下方那个区块有继续分区出五个分区，这五个由扩展分区分配继续切出来的分区，就被称为逻辑分区(logical partition)。注意：由于逻辑分割槽是由扩展分配继续分割出来的，所以他可以使用的磁柱范围就是扩展分配所配置的范围。也就是图中的101~400。 但是图中分区在Linux系统中的设备文件名分别如下：</p><blockquote><p>P1:/dev/hda1 P2:/dev/hda2 L1:/dev/hda5 L2:/dev/hda6 L3:/dev/hda7 L4:/dev/hda8 L5:/dev/hda9 </p></blockquote><p>为什么设备文件名没有/dev/hda3和/dev/hda4呢？ 因为前面四个号码都是保留给Primary和Extended用的。所以逻辑分区的设备名称号码就从5号开始了。 </p><h2 id="部分小结"><a href="#部分小结" class="headerlink" title="部分小结"></a>部分小结</h2><ol><li>主分区与扩展分区最多可以有四个(硬盘的限制)。</li><li>扩展分区最多只能有一个(操作系统的限制)。</li><li>逻辑分区是由扩展分区继续切割出来的分区。</li><li>能够被格式化后作为数据存取的分区为主分区与逻辑分区。扩展分区无法格式化。</li><li>逻辑分区的数量随着操作系统不同而不同，在Linux系统中，IDE硬盘最多有59个逻辑分区(5号到63号)， SATA硬盘则有11个逻辑分区(5号到15号)。</li></ol><p>事实上，分区是个很麻烦的东西，因为他是以磁柱为单位的”连续”磁盘空间，且扩展分区又是个类似独立的磁盘空间，所以在分区的时候得要特别注意。</p><p>如下面的两个例子。</p><p><img src="https://i.loli.net/2018/09/05/5b8f9d8fdf2a1.jpg" alt=""></p><blockquote><p>Q:在Windows操作系统当中，如果你想要将D与E盘整合成为一个新的分区，而如果有两种分区的情况如下图所示， 图中的特殊颜色区块为D与E盘的示意，请问这两种方式是否均可将D与E整合成为一个新的分区？A:第一个图中两个有色的分区是可以合并的，因为上图的D与E同属于扩展分区内的逻辑分区，因此只要将两个分区删除，然后再重新创建一个新的分区， 就能够在不影响其他分区的情况下，将两个分区的容量整合成为一个。 而第二图中的就不可以，因为D与E分属主分区与逻辑分区，两者不能够整合在一起。除非将扩展分区破坏掉后再重新分区。但如此一来会影响到所有的逻辑分区，要注意的是：如果扩展分区被破坏，所有逻辑分区将会被删除。 因为逻辑分区的信息都记录在扩展分区里面。 </p></blockquote><h2 id="开机流程与主引导分区-MBR"><a href="#开机流程与主引导分区-MBR" class="headerlink" title="开机流程与主引导分区(MBR)"></a>开机流程与主引导分区(MBR)</h2><p>大致流程:</p><ol><li>BIOS：启动主动运行的韧体，会认识第一个可启动的装置。</li><li>MBR：第一个可开机设备的第一个扇区内的住引导分区块，内含引导加载装置。</li><li>引导加载程序(boot loader)：一支可读取核心文件来运行的软件。</li><li>核心文件：开始操作系统的功能。</li></ol><p>了解主板的人知道有BIOS(Basic Input Output System)和CMOS(Complementary Metal Oxide Semiconductor)两个东西，这里简单提一下，CMOS是记录各项硬件参数且嵌入在主板上面的储存器，BIOS则是一个写入到主板上的一个韧体(再次说明，韧体就是写入到硬件上的一个软件程序)。这个BIOS就是在启动的时候，计算机系统会主动运行的第一个程序了！</p><p>接下来BIOS会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS会依据用户的设置去取得能够启动的硬盘， 并且到该硬盘里面去读取第一个扇区的MBR位置。MBR这个仅有446bytes的硬盘容量里面会放置最基本的引导加载程序，此时BIOS就功成圆满，而接下来就是MBR内的引导加载程序的工作了。</p><p>这个引导加载程序的目的是在加载(load)核心文件，由于引导加载程序是操作系统在安装的时候所提供的，所以他会认识硬盘内的文件系统格式，因此就能够读取核心文件，然后接下来就是核心文件的工作，引导加载程序也功成圆满，之后就是大家所知道的操作系统的任务啦！</p><p>由上面的说明我们会知道，BIOS与MBR都是硬件本身支持的功能，至于Boot loader则是操作系统安装在MBR上面的一套软件了。由于MBR仅有446bytes而已，因此这个引导加载程序是非常小而美的。 这个boot loader的主要任务有底下这些项目：</p><ol><li>提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能。</li><li>加载核心文件：直接指向可启动的程序区段来开始操作系统。</li><li>转交其他loader：将引导加载功能转交给其他loader负责。</li></ol><p>上面前两点还容易理解，但是第三点就有深意了。那表示你的计算机系统里面可以具有两个以上的引导加载程序。虽然我们的硬盘只有一个MBR，但是引导加载程序除了可以安装在MBR之外，还可以安装在每个分区的引导扇区(boot sector)。分区还有各自的引导扇区。这个特色才能造就”多重启动”的功能。</p><p>举个例子，假设电脑只有一个硬盘，里面分成四个分区，其中第一、二分区分别安装了Windows及Linux，你要如何在开机的时候选择用Windows还是Linux开机呢？假设MBR内安装的是可同时认识Windows/Linux操作系统的引导加载程序， 那么整个流程可以图示如下</p><p><img src="https://i.loli.net/2018/09/05/5b8f9e3169ad0.gif" alt=""></p><p>在上图中我们可以发现，MBR的引导加载程序提供两个菜单，菜单一(M1)可以直接加载Windows的核心文件来开机；菜单二(M2)则是将引导加载工作交给第二个分区的引导扇区(boot sector)。当使用者在启动的时候选择菜单二时，那么整个引导加载工作就会交给第二分区的引导加载程序了。 当第二个引导加载程序启动后，该引导加载程序内(上图中)仅有一个开机菜单，因此就能够使用Linux的核心文件来启动罗。这就是多重启动的工作情况。我们将上图作个总结：</p><ol><li>每个分区都拥有自己的引导扇区(boot sector)。</li><li>图中的系统分区为第一及第二分区。</li><li>实际可开机的核心文件是放置到各分区内的。</li><li>loader只会认识自己的系统分区内的可开机核心文件，以及其他loader而已。</li><li>loader可直接指向或者是间接将管理权转交给另一个管理程序。</li></ol><blockquote><p>Q:为什么安装多系统最好要先安装Windows再安装Linux呢?A:Linux在安装的时候，你可以选择将启动管理程序安装在MBR或各别分割槽的启动磁区，而且Linux的loader可以手动配置菜单(就是上图的M1, M2…)，所以你可以在Linux的boot loader里面加入Windows启动的选项； Windows在安装的时候，他的安装程序会主动的覆盖掉MBR以及自己所在分割槽的启动磁区，你没有选择的机会，而且他没有让我们自己选择菜单的功能。 因此，如果先安装Linux再安装Windows的话，那MBR的启动管理程序就只会有Windows的项目，而不会有Linux的项目 (因为原本在MBR内的Linux的启动管理程序就会被覆盖掉)。 </p></blockquote>]]></content>
      
      <categories>
          
          <category> 笔记本硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存条科普</title>
      <link href="/2018/09/05/%E5%86%85%E5%AD%98%E6%9D%A1%E7%A7%91%E6%99%AE/"/>
      <url>/2018/09/05/%E5%86%85%E5%AD%98%E6%9D%A1%E7%A7%91%E6%99%AE/</url>
      <content type="html"><![CDATA[<p> 我们日常使用电脑系统、软件、游戏等都是安装在硬盘中的，那么内存条是什么，到底有啥用？下面本文将通过通俗易懂的理解，来跟大家说说这个电脑内存条。</p><a id="more"></a><h3 id="内存条是什么"><a href="#内存条是什么" class="headerlink" title="内存条是什么"></a>内存条是什么</h3><blockquote><p>内存条是一种比固态硬盘更先进的存储技术，它的读写速度比硬盘快上十倍有余，以现在主流的DDR4代内存条为例，它的读写速度可以达到7000MB/s以上，而传统的机械硬盘最高也就不超过300MB/s，即使是目前最厉害的M.2 NVME固态硬盘，速度也就3000MB/s的样子.</p></blockquote><p><img src="https://i.loli.net/2018/09/05/5b8f646e7bf18.jpg" alt=""></p><h3 id="内存条有什么用"><a href="#内存条有什么用" class="headerlink" title="内存条有什么用"></a>内存条有什么用</h3><p> 既然他的读写速度这么快，那么他的作用是什么呢？由于CPU处理数据的速度是超级快的，而硬盘的读写速度又很慢，他们在进行数据交换的时候就产生了一个速度上的矛盾，就好比我（CPU）急需一件商品（数据），在马云家下单后（发出需求指令），需要等3-5天才能收到（传输太慢了），这期间我也没事做，只能干等着。<br><img src="https://i.loli.net/2018/09/05/5b8f650d97b19.jpg" alt=""></p><p> 这个时候读写速度超快的内存条就可以帮上大忙了。当我们开机或打开软件的时候，硬盘就会把这些软件需要用到的数据传输到内存条里保存起来。（这就是开机速度和打开软件或打开游戏的速度，传统的机械硬盘传输这个数据到内存条的速度很慢，所以开机和打开软件的速度很慢当软件打开后，数据就是存在内存条中了，这个时候读写速度超快的内存条就可以与CPU以超高的速度进行数据传输了，这就是为什么你打开软件和游戏需要等很久，但是在软件使用和游戏中却并没有那么明显的卡顿的原因了。当我们关闭软件或者清理后台进程时，内存条里的数据就会被删除掉。这种模式类似于京东的配货模式，事先将货物存放在本地仓库（把要用的数据放入内存条中），然后用户下单后（CPU发出指令），直接从本地仓库快速调货配送（直接从速度较快的内存条中调取数据）。</p><h3 id="内存条的容量"><a href="#内存条的容量" class="headerlink" title="内存条的容量"></a>内存条的容量</h3><p>内存条的容量自然就是能存储的数据多少了，我们每打开一个软件，这些软件的数据都会被保存到内存条中，如果内存条被塞满，我们继续打开其他软件的时候，CPU就只能从速度超慢的硬盘调取数据了，电脑肯定会卡的不行了。</p><h3 id="内存条的颗粒（重要）"><a href="#内存条的颗粒（重要）" class="headerlink" title="内存条的颗粒（重要）"></a>内存条的颗粒（重要）</h3><p><strong>颗粒就是内存条的存储数据的东西</strong>，现在主流的颗粒生产商就是 三星、海力士、镁光这三家。由于颗粒在生产时候会有质量参差不齐的情况，所以一些成色极品的颗粒会被挑选出来做成高端超频内存条，而一些成色普通但合格的颗粒会被拿去做成普通内存条。至于怎么看颗粒的好坏，我们可以从内存条的频率和时序来做一个购买前的初步判断。</p><h3 id="频率和时序（最重要）"><a href="#频率和时序（最重要）" class="headerlink" title="频率和时序（最重要）"></a>频率和时序（最重要）</h3><p>我们经常看到的2133MHz、2400MHz、3200MHz就是内存条的频率，它可以看成是内存条数据的传输速度，是内存条最重要的参数。数据跟网购的商品一样的，都是需要经过运输才能到达我们（CPU）手中，如果说内存条是一个临时存储商品的中转仓库，而数据就是货物的话，<strong>那么内存条上的频率可以理解为运输货车的载重量，频率越大，货车一次的载能运载的数据量也就越多</strong>。而我们经常提到的内存条超频，就是让这辆货车超载运行，以此来获得更多的数据传输量。（由于现在大多数正规内存条都是终身质保的，所以无需担心它的寿命问题）</p><p><img src="https://i.loli.net/2018/09/05/5b8f66d508456.jpg" alt=""></p><p><strong>还有一个很重要的参数：时序</strong>，一般用CL表示，用官方的话说就是列寻址所需的时钟周期。但在我看来，<strong>时序就是我们这个仓库的物流人员找到货物</strong>，并把货物装上车的时间，一般来说，货车的载重越大（内存条的频率越高），物流人员找到这些货物和装车所耗费的时间也就越长，<strong>所以如果是相同频率的内存条，时序CL值是越小越好（表示物流人员工作效率高）。</strong></p><p>现在普通的DDR4代内存条一般为频率2400MHz，时序CL15-17左右。但是一些使用极品颗粒的超频内存条如三星的B-die颗粒就可以轻松做到频率3200MHz，而且时序只有CL12。这类极品内存条可以做到保证时序不超标的情况下，超频上4000MHz以上。</p><p>需要注意的是，<strong>几乎所有的DDR4代的内存条默认的频率只有2133MHz，所以即使你买的是高频内存条，也需要在主板BIOS设置中打开XMP（自动超频）或手动设置超频后才能达到商家所给出的频率，而且，很多主板并不支持超过2666MHz以上的频率</strong>，所以即使你的内存条是4000MHz的神条，也会自动降频到2666MHz使用，这个需要用户去看主板上的说明。</p><h3 id="单通道和双通道内存"><a href="#单通道和双通道内存" class="headerlink" title="单通道和双通道内存"></a>单通道和双通道内存</h3><p>一般来说，两根相同规格的内存条插在主板对应的位置上就可以组成双通道了。</p><h3 id="那么双通道有什么好处"><a href="#那么双通道有什么好处" class="headerlink" title="那么双通道有什么好处"></a>那么双通道有什么好处</h3><p>CPU与内存条之间的数据传输是有来有回的，单通道就相当于一条马路分左右车道，一个车道负责去，一个车道负责回。 虽然秩序井然但是由于马路（带宽）较窄，数据流量不会很大。<strong>双通道就相当于又修了一条同样的马路，这样的话，这两条马路一条负责收，一条负责发，马路整体（带宽）宽了一倍，流量自然也就增加了。</strong></p><p> <strong>双通道是能带来一些性能的提升的，特别是使用CPU核心显卡的用户</strong>，由于CPU要同时负责程序数据和显示数据的处理，需要的数据转载自电脑百事网流量更大，所以双通道带来的双倍带宽才能满足这么大的数据流量的需求。</p><h3 id="内存选购技巧"><a href="#内存选购技巧" class="headerlink" title="内存选购技巧"></a>内存选购技巧</h3><h4 id="1、要先确认自己的主板是用的DDR3还是DDR4的内存条"><a href="#1、要先确认自己的主板是用的DDR3还是DDR4的内存条" class="headerlink" title="1、要先确认自己的主板是用的DDR3还是DDR4的内存条"></a>1、要先确认自己的主板是用的DDR3还是DDR4的内存条</h4><p>一般来说近些年的新电脑都是DDR4的，老电脑是DDR3的（甚至有更古董的DDR2），这个可以在主板上找到（笔记本用户可以用鲁大师检测一下）。</p><p><img src="https://i.loli.net/2018/09/05/5b8f68650dc25.jpg" alt=""></p><h4 id="2、选择容量"><a href="#2、选择容量" class="headerlink" title="2、选择容量"></a>2、选择容量</h4><p>根据个人需求选择合适容量的内存条。对于普通用户来说8GB是够用的，如果是专业作图设计或者玩吃鸡和大型单机游，可以选择2根8GB组双通道。如果自己也不知道自己需要多少容量的，可以先买一根8GB的使用，发现不够可以再买一根8GB。</p><h4 id="3、选择频率"><a href="#3、选择频率" class="headerlink" title="3、选择频率"></a>3、选择频率</h4><p>DDR3代的内存条频率一般为1333MHz 和 1666MHz。DDR4代的内存条频率一般为：2133MHz 和 2400MHz，如果你的主板支持，也可以选择更高的如3200MHz或4266MHz的高频条。超高频率的内存条固然能给游戏带来一点性能提升，但是需要更高端的主板和CPU的支持，普通用户选择2400MHz的也已经足够用了。吃鸡游戏玩家根据预算合理选择更高频率的内存条。</p><p>注意：<code>如果有两根或多根不同频率的内存条同时使用，会按照其中频率最低的来统一频率</code>。比如有一根2133MHz、一根2400MHz、一根3200MHz的内存条同时使用的话，所有内存条都是按照2133MHz来使用。所以如果是升级内存条的用户，一定要看看已有的是多少频率的，不要盲目购买高频内存条。</p><h4 id="4-对比时序"><a href="#4-对比时序" class="headerlink" title="4.对比时序"></a>4.对比时序</h4><p>选择好频率后，就要货比三家对比一下CL时序了，一般商家都会在商品信息中标出来，同一频率时序越低，性能越好。</p><p><img src="https://i.loli.net/2018/09/05/5b8f69260a938.jpg" alt=""></p><h4 id="5-关于PCB板层数"><a href="#5-关于PCB板层数" class="headerlink" title="5.关于PCB板层数"></a>5.关于PCB板层数</h4><p>PCB板就是电路板，一些厂家会说自己家的内存条用了8层或者10层PCB板。这个可不单单是说他这个内存条比较厚实，更重要的是层数增加后，电路板内部的电路走线层数增加，这样的话，电路走线就不用那么拥挤，可以适当增加每根铜线的宽度，这样就会有更好的电气性能，使得超频更加稳定。</p>]]></content>
      
      <categories>
          
          <category> 笔记本硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NexT主题设置</title>
      <link href="/2018/07/17/NexT%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/07/17/NexT%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>NexT是一款简洁优雅且易于使用的主题，配置比较简单，只需要稍微修改配置文件即可，功能也比较全，分类、归档、标签显示明了。</p><a id="more"></a><blockquote><p>Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为<code>站点配置文件</code>，后者称为<code>主题配置文件</code>。</p></blockquote><h3 id="安装-NexT"><a href="#安装-NexT" class="headerlink" title="安装 NexT"></a>安装 NexT</h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>如果你熟悉 <a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a>， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 <code>git pull</code> 来快速更新， 而不用再次下载压缩包替换。</p><p>在终端窗口下，定位到 Hexo 站点目录下。使用 <code>Git</code> checkout 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><p>启用 NexT 主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p><p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p><p><img src="https://theme-next.iissnan.com/uploads/five-minutes-setup/validation-default-scheme-mac.png" alt="img"></p><p>现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p><h3 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h3><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p><ul><li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li><li>Pisces - 双栏 Scheme，小家碧玉似的清新</li></ul><p>Scheme 的切换通过更改 <code>主题配置文件</code>，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 <code>#</code> 去除即可。</p><p>本人选择的是Pisces外观，所以本人配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure><h3 id="设置-头像"><a href="#设置-头像" class="headerlink" title="设置 头像"></a>设置 头像</h3><p>编辑 主题配置文件， 修改字段 <code>avatar</code>， 值设置成头像的链接地址。其中，头像的链接地址可以是：</p><table><thead><tr><th style="text-align:left">地址</th><th>值</th></tr></thead><tbody><tr><td style="text-align:left">完整的互联网 URI</td><td><a href="http://example.com/avatar.png" target="_blank" rel="noopener">http://example.com/avatar.png</a></td></tr><tr><td style="text-align:left">站点内的地址</td><td>将头像放置主题目录下的 <code>source/uploads/</code> （新建 uploads 目录若不存在） 配置为：<code>avatar: /uploads/avatar.png</code></td></tr></tbody></table><h3 id="设置-作者昵称"><a href="#设置-作者昵称" class="headerlink" title="设置 作者昵称"></a>设置 作者昵称</h3><p>编辑 站点配置文件， 设置 <code>author</code> 为你的昵称。</p><h3 id="站点描述"><a href="#站点描述" class="headerlink" title="站点描述"></a>站点描述</h3><p>编辑 站点配置文件， 设置 <code>description</code> 字段为你的站点描述。站点描述可以是你喜欢的一句签名:)</p><h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><p>NexT主题菜单设置，用于设置博客上方导航栏，在<code>主题配置文件</code>中修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  home: /                      #主页</span><br><span class="line">  categories: /categories   #分类页（需手动创建）</span><br><span class="line">  #about: /about      #关于页面（需手动创建）</span><br><span class="line">  archives: /archives   #归档页</span><br><span class="line">  tags: /tags       #标签页（需手动创建）</span><br><span class="line">  #commonweal: /404.html        #公益 404 （需手动创建）</span><br></pre></td></tr></table></figure><p><strong>只是在menu选项中设置还不能让标签页面、分类页面生效，需要我们手动创建</strong> </p><h4 id="标签页面"><a href="#标签页面" class="headerlink" title="标签页面"></a>标签页面</h4><p>1.运行以下命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>同时，在/source目录下会生成一个tags文件夹，里面包含一个<code>index.md</code>文件</p><p> 2.修改/source/tags目录下的<code>index.md</code>文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2015-09-29 14:37:02</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>3.修改<code>主题配置文件</code> 去掉tags的注释 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line"></span><br><span class="line">  home: /                     #主页</span><br><span class="line">  categories: /categories #分类页（需手动创建）</span><br><span class="line">  #about: /about     #关于页面（需手动创建）</span><br><span class="line">  archives: /archives #归档页</span><br><span class="line">  tags: /tags           #标签页（需手动创建）</span><br><span class="line">  #commonweal: /404.html       #公益 404 （需手动创建）</span><br></pre></td></tr></table></figure><h4 id="分类页面"><a href="#分类页面" class="headerlink" title="分类页面"></a>分类页面</h4><p>1.运行以下命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>2.修改/source/categories目录下的<code>index.md</code>文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2015-09-29 14:47:21</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>3.修改<code>主题配置文件</code> 去掉categories的注释 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /                   #主页</span><br><span class="line">  categories: /categories   #分类页（需手动创建）</span><br><span class="line">  #about: /about   #关于页面（需手动创建）</span><br><span class="line">  archives: /archives    #归档页</span><br><span class="line">  tags: /tags   #标签页（需手动创建）</span><br><span class="line">  #commonweal: /404.html    #公益 404 （需手动创建）</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 玩转Hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo搭建博客</title>
      <link href="/2018/07/17/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/17/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><u>Hexo</u> 是一个快速、简洁且高效的博客框架，支持 Marddown，可以将支持的类型的文件转换成静态网页。</p><a id="more"></a><p>网上有很多高质量的 hexo 教程，但是考虑到专家盲点，大家在自己搭建博客的时候总是会遇到一些无法预料的问题，于是我决定与大家分享搭建博客的过程。</p><blockquote><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 </p></blockquote><blockquote><p>专家盲点是指一些专精某个领域的专家，因为太精通，以至于他忘记了当他不是专家时所遇到的困难。 </p></blockquote><h2 id="安装必须的软件"><a href="#安装必须的软件" class="headerlink" title="安装必须的软件"></a>安装必须的软件</h2><p>为了能够上传博客和安装 hexo，我们分别需要安装 Git 和 Node.js。 </p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>在 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a> 即可下载，可能需要科学上网，可以选择电脑硬盘中任意位置安装。 </p><h4 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h4><p>在开始菜单栏中找到 Git bush 并打开，输入如下两行命令行。推荐使用 Github 的用户名和邮箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><h4 id="检查配置是否成功"><a href="#检查配置是否成功" class="headerlink" title="检查配置是否成功"></a>检查配置是否成功</h4><p>将同样命令取掉最后的名字和邮箱地址重新输入，如果显示了您刚才输入的信息说明配置成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name</span><br><span class="line">$ git config --global user.email</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/07/17/5b4d4cc41695d.png" alt=""></p><p><strong> 此处的username example 需要用户自行输入</strong></p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript <strong>运行环境</strong>。同样的，您只需要知道 Node.js 是 hexo 的运行环境即可。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a> 即可下载，可以选择电脑硬盘中任意位置安装。</p><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><p><strong>win+R 打开运行菜单</strong>，输入 <strong>cmd</strong> 打开一个命令行窗口，输入两行简单的命令检查 Node.js 和 npm 是否安装成功（npm是Node.js的包管理工具，安装Node.js的时候默认安装）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p><a href="https://cnmarijuana.github.io/2017/12/08/Hello-Hexo/node.png" target="_blank" rel="noopener"><img src="https://cnmarijuana.github.io/2017/12/08/Hello-Hexo/node.png" alt="node配置演示"></a></p><h4 id="配置环境变量（可选操作）"><a href="#配置环境变量（可选操作）" class="headerlink" title="配置环境变量（可选操作）"></a>配置环境变量（可选操作）</h4><p>Node.js 默认安装模块的位置在 C:\Users\Username\AppData\Roaming\npm 文件夹中，如果需要更换可通过更改环境变量的方式。参照<a href="http://www.jianshu.com/p/03a76b2e7e00" target="_blank" rel="noopener"> Node.js 安装及环境配置</a>。</p><p>在更改了默认的安装位置后可再次用上面两行命令检查是否配置成功，配置环境变量是搭建博客过程中最容易出错的地方，这一步可以多换几个路径检查。</p><h2 id="申请Github仓库"><a href="#申请Github仓库" class="headerlink" title="申请Github仓库"></a>申请Github仓库</h2><h3 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h3><p>打开<a href="https://github.com/" target="_blank" rel="noopener"> Github </a>创建账号即可，建议与本地配置 Git 的时候使用的名字和邮箱相同。不要忘记去您的邮箱验证邮箱地址。</p><h3 id="创建和配置代码仓库"><a href="#创建和配置代码仓库" class="headerlink" title="创建和配置代码仓库"></a>创建和配置代码仓库</h3><ol><li><p>登陆 Github 后依次点击右上角 “+”，New repository，然后设置仓库名和仓库属性，点击 Create reopsitory即可。</p></li><li><p>注意：仓库名应该设置为 Github昵称.github.io，结尾的 github.io 不能变。</p><p><img src="https://i.loli.net/2018/07/17/5b4d4e4c1260c.png" alt=""></p><p><em>图中的提示为已有同名仓库，是因为我已经创建好了仓库，您应该不会出现同样的提示。</em> </p></li><li><p>如果您的代码仓库设置没有问题的话，在代码仓库设置中可以找到Github Pages </p></li></ol><p><img src="https://i.loli.net/2018/07/17/5b4d4f517c101.png" alt=""></p><p>选择 master branch</p><p>2.记录下代码仓库的地址等会使用。 </p><h2 id="安装和配置Hexo"><a href="#安装和配置Hexo" class="headerlink" title="安装和配置Hexo"></a>安装和配置Hexo</h2><p>在经历了漫长的准备工作之后，终于迎来了我们的主角 — hexo。</p><h3 id="一行命令安装"><a href="#一行命令安装" class="headerlink" title="一行命令安装"></a>一行命令安装</h3><p>打开一个 cmd 命令行窗口，输入如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>在安装的时候可能会提示警告信息，笔者在安装时遇到的警告信息大意为要求 32 位系统，但实际为 64 位系统。如果您遇到了与我相同的警告信息，不用紧张，不会影响您接下来的使用。</p><h3 id="检查hexo是否安装成功"><a href="#检查hexo是否安装成功" class="headerlink" title="检查hexo是否安装成功"></a>检查hexo是否安装成功</h3><p>如果您更改了 Node.js 和 npm 的默认下载位置，这一步更加重要。<br>打开一个 cmd 命令行窗口，在多个路径下使用这行命令检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><ul><li>如果在每个路径下都能正常输出 hexo 的版本信息，说明 hexo 安装成功并且 Node.js 和 npm 的设置正确。</li><li>如果仅在指定路径下能正常输出 hexo 的版本信息，说明 hexo 安装成功但是 Node.js 和 npm的设置出现问题。</li></ul><h3 id="创建博客根目录"><a href="#创建博客根目录" class="headerlink" title="创建博客根目录"></a>创建博客根目录</h3><p>打开一个新的 cmd 窗口，跳转到您想要的路径，输入如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># &lt;folder&gt;是指定的博客根目录（folder为您指定的文件夹名）</span><br><span class="line">$ hexo init folder</span><br><span class="line"></span><br><span class="line"># 安装完成之后进入博客目录下</span><br><span class="line">$ cd folder</span><br><span class="line"></span><br><span class="line"># 安装Git支持插件</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>笔者的博客本地文件目录为 E:\myBlog，在输入 hexo init myBlog 后 hexo 帮我创建成功的。</p><h3 id="配置博客文件"><a href="#配置博客文件" class="headerlink" title="配置博客文件"></a>配置博客文件</h3><p>在您上一步创建好的文件夹中，应该有一个名为：_config.yml 的文件，用记事本打开后进行编辑。</p><p><strong>1. Site设置</strong>，从配置文件的第四行开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: MyBlog</span><br><span class="line">subtitle:</span><br><span class="line">description: 我曾踏足山巅，也曾陷入低谷</span><br><span class="line">author: Little Young</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><ul><li>title 为博客名，与网站名相同。</li><li>subtitile 为关键字，您可以添加一些对博客主要内容的描述，以便搜索引擎更好的找到您的博客。</li><li>descriptio 为描述，我在这里添加了一句座右铭。</li><li>author 为作者，在这里填入您自己的名字即可。</li></ul><p><strong>2. URL设置</strong>（既指定的博客网址），就在Site设置的下边，应该能找到如下字段。 在这一部分的第三行输入您想要的博客网址即可，格式为 <a href="https://xxxxx.github.io/" target="_blank" rel="noopener">https://xxxxx.github.io/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://yangpengze.github.io/</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p><strong>3. 部署方式配置</strong>，按下 ctrl+f 打开查找窗口，输入 Deployment 找到后添加如下字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/Yangpengze/Yangpengze.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ul><li>type指定部署方式，当然是我们提前配置好的Git。</li><li>repo指定部署地址，输入我们提前申请好的Github仓库地址。</li><li>branch为项目分支，输入master表示主分支即可。</li></ul><p><strong>注意</strong>配置文件中每一项前都有一个空格，如”title: MyBlog”中就有一个空格，下同。</p><p><strong>注意</strong>如果您在配置文件中使用了中文字符，需要更改编码方式为UTF-8，请确保图中重点位置正确。 </p><h2 id="写一篇文章"><a href="#写一篇文章" class="headerlink" title="写一篇文章"></a>写一篇文章</h2><h3 id="文章地址"><a href="#文章地址" class="headerlink" title="文章地址"></a>文章地址</h3><p>文章文件在本地博客文件夹 source/_post 文件夹下，目前应该已经含有一篇 hello-world.md 的文章，我们就尝试利用这篇文章生成和上传博客。</p><h3 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h3><p>在更改完博客的配置文件后，我们终于迎来了最后一步，可以使用 hexo 生成博客了。打开一个新的 cmd 命令行窗口，在博客路径下输入如下命令。如果报错说明配置文件的修改出了问题，请检查您的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate </span><br><span class="line">#或者简写</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><p>如果上一步没有报错的话，继续输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">#或者简写</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>当命令行显示 “Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>. Press Ctrl+C to stop.” 时在浏览器地址栏中输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可预览博客。</p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>折腾了这么久，终于要将写好的博客上传到网络，不过首先请您确保之前的步骤都没有出现问题。<br>同样在命令行窗口输入如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">#或者简写</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>第一次上传时会有一个来自 github 的弹框需要您输入 github 的账号和密码，正确输入即可。如果遇到错误代码为0的问题，可以尝试更新 git。</p><h2 id="写一篇新文章"><a href="#写一篇新文章" class="headerlink" title="写一篇新文章"></a>写一篇新文章</h2><p>当然，我们搭建博客是为了展示自己写的文章的，不是为了展示默认文章，现在我就教您如何写一篇新文章。</p><ul><li>使用 hexo 命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new name</span><br></pre></td></tr></table></figure><p>在博客根目录下输入如下命令后会在source/_post文件夹下创建一个名为name.md的文件，使用Markdown编辑器打开即可编写您自己的文章。</p><ul><li>将提前写好的 Markdowm 文件直接放进 source/_post 文件夹中也可以为博客添加一篇新文章。</li></ul><p>两种方法中我更推荐第一种，因为 hexo 会帮您在 name.md 文件中添加一些标记，以便于您在博客中对文章进行分类和归档等。日后您写好新的文章也可以按照相同方式生成本地文件后上传文件。</p><hr><p>本文转载自<a href="https://cnmarijuana.github.io/2017/12/08/Hello-Hexo/" target="_blank" rel="noopener">https://cnmarijuana.github.io/2017/12/08/Hello-Hexo/</a></p>]]></content>
      
      <categories>
          
          <category> 玩转Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>部署VPS服务器</title>
      <link href="/2018/07/16/%E9%83%A8%E7%BD%B2VPS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/07/16/%E9%83%A8%E7%BD%B2VPS%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p> 省略在vultr官网购买服务器的环节</p><p> 直接展示部署服务器的操作</p><a id="more"></a> <p>​    购买服务器后，需要重新部署一下。购买服务器后，需要部署一下。因为你买的是虚拟东西，而且又远在国外，我们需要一个叫Xshell的软件来远程部署。</p><p><a href="https://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="noopener">Xshell 6 官方下载地址</a></p><p><strong>无需购买，可以下载学生版，官方提供免费许可证，具体请参照官网</strong></p><hr><h4 id="部署教程："><a href="#部署教程：" class="headerlink" title="部署教程："></a>部署教程：</h4><h5 id="xshell连接ip"><a href="#xshell连接ip" class="headerlink" title="xshell连接ip"></a>xshell连接ip</h5><p>下载 windows xshell 软件并安装后，打开软件</p><p><img src="https://i.loli.net/2018/07/16/5b4c4e77540cb.png" alt=""></p><p>选择文件，新建</p><p><img src="https://i.loli.net/2018/07/16/5b4c4e774eb1a.png" alt=""></p><p>随便取个名字，然后把你的服务器ip填上 </p><p><img src="https://i.loli.net/2018/07/16/5b4c4e77652f7.png" alt=""></p><p>连接国外ip即服务器时，软件会先后提醒你输入用户名和密码，用户名默认都是root，密码是你购买的服务器系统的密码。 </p><p><strong>如果xshell连不上服务器，没有弹出让你输入用户名和密码的输入框，表明你开到的ip是一个被墙的ip，遇到这种情况，重新开新的服务器，直到能用xshell连上为止，耐心点哦！如果同一个地区开了多台服务器还是不行的话，可以换其它地区。</strong></p><p><img src="https://i.loli.net/2018/07/16/5b4c4e77781ca.png" alt=""></p><hr><p><strong>上文所示的ip 以及密码都可以在vultr处所开通的服务器处得到</strong></p><hr><p><img src="https://i.loli.net/2018/07/16/5b4c515f21fc8.png" alt=""></p><h5 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h5><p>连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。</p><p>CentOS6/Debian6/Ubuntu14 ShadowsocksR一键部署管理脚本：</p><hr><p>yum -y install wget</p><p>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p><p>备用脚本：</p><p>yum -y install wget</p><p>wget -N –no-check-certificate <a href="https://softs.fun/Bash/ssr.sh" target="_blank" rel="noopener">https://softs.fun/Bash/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p><hr><p>复制上面的代码(二选一)到VPS服务器里，复制代码用鼠标右键的复制，然后在vps里面右键粘贴进去，因为ctrl+c和ctrl+v无效。接着按回车键，脚本会自动安装，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：bash ssr.sh </p><p><img src="https://i.loli.net/2018/07/16/5b4c52b2b0203.png" alt=""></p><p>如上图出现管理界面后，<strong>输入数字1来安装SSR服务端</strong>。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh 再尝试。 </p><p><img src="https://i.loli.net/2018/07/16/5b4c52fd4a062.png" alt=""></p><p>根据上图提示，依次输入自己想设置的<strong>端口和密码</strong> (<strong>密码建议用复杂点的字母组合，端口号为40-65535之间的数字</strong>)，回车键用于确认</p><p>注：关于端口的设置，总的网络总端口有6万多个，理论上可以任意设置，但不要以0开头！但是有的地区需要设置特殊的端口才有效，一些特殊的端口比如80、143、443、1433、3306、3389、8080。</p><p><img src="https://i.loli.net/2018/07/16/5b4c5341ddf21.png" alt=""></p><p>如上图，选择想设置的<strong>加密方式</strong>，比如10，按回车键确认</p><p>接下来是选择<strong>协议插件</strong>，如下图：</p><p><img src="https://i.loli.net/2018/07/16/5b4c536a50c78.png" alt=""></p><p><img src="https://i.loli.net/2018/07/16/5b4c53cd9ac2f.png" alt=""></p><p>选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端（SS客户端没有协议和混淆的选项），可以根据需求进行选择，演示选择y</p><p>之后进行混淆插件的设置。</p><p><strong>注意：如果协议是origin，那么混淆也必须是plain；如果协议不是origin，那么混淆可以是任意的。有的地区需要把混淆设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。（特别注意：tls 1.2_ticket_auth容易受到干扰！请选择除tls开头以外的其它混淆！！！）</strong></p><p> <img src="https://i.loli.net/2018/07/16/5b4c53a08ca31.png" alt=""></p><p>进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。</p><p>注意：关于限制设备数，这个协议必须是非原版且不兼容原版才有效，也就是必须使用SSR协议的情况下，才有效！</p><p><img src="https://i.loli.net/2018/07/16/5b4c5466042e1.png" alt=""></p><p>之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入：y </p><p><img src="https://i.loli.net/2018/07/16/5b4c55e608d52.png" alt=""></p><p>耐心等待一会，出现下面的界面即部署完成： </p><p><img src="https://i.loli.net/2018/07/16/5b4c5605544ed.png" alt=""></p><p><img src="https://i.loli.net/2018/07/16/5b4c56586d123.png" alt=""></p><p>根据上图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件，这些信息需要填入你的SSR客户端。<strong>如果之后想修改账号信息，直接输入快捷管理命令：bash ssr.sh 进入管理界面，选择相应的数字来进行一键修改。</strong>例如： </p><p><img src="https://i.loli.net/2018/07/16/5b4c56a1dd11d.png" alt=""></p><p><img src="https://i.loli.net/2018/07/16/5b4c56bb91320.png" alt=""></p><h5 id="脚本演示结束。"><a href="#脚本演示结束。" class="headerlink" title="脚本演示结束。"></a><strong>脚本演示结束。</strong></h5><p>此脚本是开机自动启动，部署一次即可。最后可以重启服务器确保部署生效（一般情况不重启也可以）。重启需要在命令栏里输入reboot ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。</p><hr><h4 id="第三步：一键加速VPS服务器"><a href="#第三步：一键加速VPS服务器" class="headerlink" title="第三步：一键加速VPS服务器"></a><strong>第三步：一键加速VPS服务器</strong></h4><p>此加速教程为谷歌BBR加速,Vultr的服务器框架可以装BBR加速，加速后对速度的提升很明显，所以推荐部署加速脚本。该加速方法是开机自动启动，部署一次就可以了。</p><p>按照第二步的步骤，连接服务器ip，登录成功后，在命令栏里粘贴以下代码：</p><p>【谷歌BBR加速教程】</p><p>yum -y install wget</p><p>wget –no-check-certificate <a href="https://github.com/teddysun/across/raw/master/bbr.sh" target="_blank" rel="noopener">https://github.com/teddysun/across/raw/master/bbr.sh</a></p><p>chmod +x bbr.sh</p><p>./bbr.sh</p><p>把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。</p><p>演示开始，如图：</p><p>复制并粘贴代码后，按回车键确认</p><p><img src="https://i.loli.net/2018/07/16/5b4c570131846.png" alt=""></p><p>如下图提示，按任意键继续部署 </p><p><img src="https://i.loli.net/2018/07/16/5b4c5722e32b1.png" alt=""></p><p><img src="https://i.loli.net/2018/07/16/5b4c5735df790.png" alt=""></p><p>部署到上图这个位置的时候，等待3～6分钟 </p><p><img src="https://i.loli.net/2018/07/16/5b4c574fb1b5d.png" alt=""></p><p>最后输入y重启服务器，如果输入y提示command not found ，接着输入reboot来重启服务器，确保加速生效，bbr加速脚本是开机自动启动，装一次就可以了。</p><p>服务器重启成功并重新连接服务器后，输入命令lsmod | grep bbr 如果出现tcp_bbr字样表示bbr已安装并启动成功。如图：</p><p><img src="https://i.loli.net/2018/07/16/5b4c576f9a589.png" alt=""></p><hr><h4 id="【SSR客户端下载】"><a href="#【SSR客户端下载】" class="headerlink" title="【SSR客户端下载】"></a>【SSR客户端下载】</h4><p>第一次电脑系统使用SSR/SS客户端时，如果提示你需要安装NET Framework 4.0，网上搜一下这个东西，安装一下即可。NET Framework 4.0是SSR/SS的运行库，没有这个SSR/SS客户端无法正常运行。有的电脑系统可能会自带NET Framework 4.0。</p><p>windows SSR客户端</p><p><a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank" rel="noopener">下载地址</a></p><p><a href="https://nofile.io/f/6Jm7WJCyOVv/ShadowsocksR-4.7.0-win.7z" target="_blank" rel="noopener">备用下载地址</a></p><p><strong>有了账号后，打开SSR客户端，填上信息，这里以windows版的SSR客户端为例子</strong>： </p><p><img src="https://i.loli.net/2018/07/16/5b4c5877e0a81.png" alt=""></p><p>在对应的位置，填上服务器ip、服务器端口、密码、加密方式、协议和混淆，最后将浏览器的代理设置为（http）127.0.0.1和1080即可。账号的端口号就是你自己设置的，而要上网的浏览器的端口号是1080，固定的，谷歌浏览器可以通过 SwitchyOmega 插件来设置。</p><p>启动SSR客户端后，右键SSR客户端图标，选择第一个“系统代理模式”，里面有3个子选项，选择”全局模式“，之后就可以用浏览器设置好了的代理模式（http）127.0.0.1和1080翻墙，此模式下所有的网站都会走SSR代理。</p><p><img src="https://i.loli.net/2018/07/16/5b4c58962184c.png" alt=""></p><hr><h4 id="常见问题参考解决方法："><a href="#常见问题参考解决方法：" class="headerlink" title="常见问题参考解决方法："></a><strong>常见问题参考解决方法</strong>：</h4><p>1、用了一段时间发现ssr账号用不了了</p><p>首先ping一下自己的ip，看看能不能ping的通，ping不通那么就是ip被墙了，ip被墙时，xshell也会连接不上服务器，遇到这种情况重新部署一个新的服务器，新的服务器就是新的ip。关于怎么ping ip的方法，可以自行网上搜索，或者用xshell软件连接服务器来判断，连不上即是被墙了。vultr开通和删除服务器非常方便，新服务器即新ip，大多数vps服务商都没有这样的服务，一般的vps服务商可能会提供免费更换1次ip的服务。</p><p>2、刚搭建好的ssr账号，ip能ping通，但是还是用不了</p><p>首选排除杀毒软件的干扰，尤其是国产杀毒软件，比如360安全卫生、360杀毒软件、腾讯管家、金山卫生等。这些东西很容易干扰翻墙上网，如果你的电脑安装了这样的东西，建议至少翻墙时别用，最好卸载。其次，检查下SSR信息是否填写正确。浏览器的代理方式是否是ssr代理，即（HTTP）127.0.0.1 和1080。如果以上条件都排除，还是用不了，那么可以更换端口、加密方式、协议、混淆，或者更换服务器位置。另外，如果你的vps服务器配置的是SSR账号，即有协议和混淆且没有兼容原版(SS版），那么你必须使用SSSR客户端来使用账号，因为SS客户端没有填写协议和混淆的选项。</p><p>3、有的地区需要把混淆参数设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。</p><p>4、电脑能用但手机用不了</p><p>如果你的手机用的是SS客户端，SS客户端没有填协议和混淆的地方，如果你部署的协议和混淆的时候没有选择兼容原版（SS版），因此手机是用不了的。这个时候你把协议弄成兼容原版、混淆也设置成兼容原版即可。或者直接将协议设置成origin且混淆设置成plain。</p><p>5、vps的服务器操作系统不要用的太高，太高可能会因为系统的防火墙问题导致搭建的SSR账号连不上，如果你用的centos系统，建议用centos6，不要用centos7。如果你前面不小心装了centos7系统，那么只能重装系统或者重新部署新的vps服务器。</p><p>6、vultr服务商提供的vps服务器是单向流量计算，有的vps服务商是双向流量计算，单向流量计算对于用户来说更实惠。因为我们是在vps服务器上部署SSR服务端后，再用SSR客户端翻墙，所以SSR服务端就相当于中转，比如我们看一个视频，必然会产生流量，假如消耗流量80M，那么VPS服务器会产生上传80M和下载80M流量，vultr服务商只计算单向的80M流量。如果是双向计算流量，那么会计算为160M流量。</p><p>7、如果你想把搭建的账号给多人使用，不用额外设置端口，因为一个账号就可以多人使用。一般5美元的服务器可以同时支持40人在线使用。</p><p>如果想实现支持每个用户(端口)不同的加密方式/协议/混淆等，并且管理流量使用，可以参考多用户配置脚本：wget -N –no-check-certificate <a href="https://softs.fun/Bash/ssrmu.sh" target="_blank" rel="noopener">https://softs.fun/Bash/ssrmu.sh</a> &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 备用脚本：wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh</a> &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 安装后管理命令为：bash ssrmu.sh</p><p><strong>注意：这个多用户配置脚本和教程内容的脚本无法共存！要想用这个脚本，把之前的脚本卸载，输入管理命令bash ssr.sh ，选择3，卸载ShadowsocksR即可卸载原脚本。</strong></p><p>8、vultr服务器每月有流量限制，超过限制后服务器不会被停止运行，但是超出的流量会被额外收费。北美和西欧地区的服务器超出流量后，多出的部分收费为0.01美元/G。新加坡和日本东京（日本）为0.025美元/G，悉尼（澳大利亚）为0.05美元/G。把vultr服务器删掉，开通新的服务器，流量会从0开始重新计算。</p>]]></content>
      
      <categories>
          
          <category> VPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
